<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<!-- #BeginTemplate "../../Main/Opti_Fx.dwt" -->

<head>
<meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
<!-- #BeginEditable "doctitle" -->
<title>symJac</title>
<!-- #EndEditable -->
<link href="../../Main/Opti_Styles.css" rel="stylesheet" type="text/css" />
</head>

<body>

<!-- #BeginEditable "FunctionTop" -->
<p class="CodeHeading1">symJac</p>
<p class="Normal">Return a symbolically generated gradient / Jacobian from a 
function handle</p>
<!-- #EndEditable -->
<table class="TableBreakLine"><tr><td></td></tr></table>
<!-- #BeginEditable "Syntax" -->
<p class="Heading2">Syntax</p>
<p class="Syntax">jac = symJac(fun)</p>
<p class="Syntax">jac = symJac(fun,nvar)</p>
<p class="Syntax">jac = symJac(fun,nvar,tran)</p>
<p class="Syntax">jac = symJac(fun,ncol,tran,var)</p>
<p class="Syntax">jac = symJac(fun,ncol,tran,var,file)</p>
<p class="Syntax">[jac,pattern] = symJac(fun)</p>
<p class="Syntax">[jac,pattern,symjac] = symJac(fun)</p>
<!-- #EndEditable -->
<table class="TableBreakLine"><tr><td></td></tr></table>
<!-- #BeginEditable "Description" -->
<p class="Heading2">Description</p>
<p class="Normal"><span class="Code">jac = symJac(fun)</span> converts the 
function handle <span class="Code">fun</span> into a symbolic expression, 
differentiates it using the Symbolic Toolbox command <span class="Code">Jacobian</span>, 
then converts it back to a function handle as <span class="Code">jac</span>.</p>
<p class="Normal"><span class="Code">jac = symJac(fun,nvar)</span> ensures the 
correct number (<span class="Code">nvar</span>) of variables is used in the 
resulting gradient / Jacobian. This is useful if your function does not include 
all indices of <span class="Code">x</span><span class="Normal">.</span></p>
<p class="Normal"><span class="Code">jac = symJac(fun,nvar,tran)</span> returns 
the function transposed.</p>
<p class="Normal"><span class="Code">jac = symJac(fun,nvar,tran,var)</span> 
allows a variable other than <span class="Code">'x'</span> to be parsed from the 
expression.</p>
<p class="Normal"><span class="Code">jac = symJac(fun,nvar,tran,var,file)</span> 
writes the symbolic Jacobian to a file, rather than returning it as an anonymous 
function. Only supports .m files currently.</p>
<p class="Normal"><span class="Code">[jac,pattern] = symJac(fun)</span> returns 
the Jacobian sparsity pattern as a function handle.</p>
<p class="Normal"><span class="Code">[jac,pattern,symjac] = symJac(fun)</span> 
also returns the intermediate symbolic expression of the gradient / Jacobian.</p>
<table class="TableBreakLine"><tr><td></td></tr></table><p class="Heading2">Important Notes</p>
<p class="Normal">This function uses the Matlab Symbolic Toolbox<sup>&reg;</sup> 
thus you must have this installed to use this function. This is also a very 
basic routine thus you may wish to confirm the solution via one of the other 
differentiation routines provided.</p>
<p class="Normal">The form of your function handle must be as follows:</p>
<p class="Normal"><span class="Code">fun = @(x) x(1) + x(2);</span>&nbsp; where 
the function is only a function of <span class="Code">x</span>, and
<span class="Code">x</span> is indexed into the expression (no vectorized 
calls). </p>
<table class="TableBreakLine"><tr><td></td></tr></table><p class="Heading2">Example</p>
<p class="Code">
&gt;&gt; fun = @(x) 
3*x(1)^2 + 4*sin(x(2));</p>
<p class="Code">
&gt;&gt; jac = symJac(fun)<br />
<br />
jac = <br />
<br />
@(x)[[6*x(1),4*cos(x(2))]]</p>
<!-- #EndEditable -->

<table class="TableBreakLine"><tr><td></td></tr></table>
<p class="Copyright">Copyright Â© 2011-2013 Jonathan Currie (I<sup>2</sup>C<sup>2</sup>) </p>
</body>

<!-- #EndTemplate -->

</html>
